<!DOCTYPE html>

<head>
	<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
	<title>AR Multiple Objects</title>

	<script src='js/three.js'></script>
	<script src='js/OBJLoader.js'></script>
	<script src='js/MTLLoader.js'></script>
	<script src="jsartoolkit5/artoolkit.min.js"></script>
	<script src="jsartoolkit5/artoolkit.api.js"></script>
	<script src="threex/threex-artoolkitsource.js"></script>
	<script src="threex/threex-artoolkitcontext.js"></script>
	<script src="threex/threex-arbasecontrols.js"></script>
	<script src="threex/threex-armarkercontrols.js"></script>
	<script src="https://cdn.jsdelivr.net/npm/three@0.138.3/build/three.min.js"></script>
	<script src="https://cdn.jsdelivr.net/npm/three@0.138.3/examples/js/loaders/GLTFLoader.js"></script>
</head>

<body style='margin : 0px; overflow: hidden; font-family: Monospace;'>

	<script>

		var scene, camera, renderer, clock, deltaTime, totalTime;
		var arToolkitSource, arToolkitContext;

		initialize();
		animate();

		function initialize() {
			scene = new THREE.Scene();

			let ambientLight = new THREE.AmbientLight(0xffffff, 1);
			scene.add(ambientLight);

			const light = new THREE.DirectionalLight(0xffffff, 1.5);
			light.position.set(1, 2, 3);
			scene.add(light);

			camera = new THREE.Camera();
			scene.add(camera);

			renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
			renderer.setClearColor(new THREE.Color('lightgrey'), 0);
			renderer.setSize(640, 480);
			renderer.domElement.style.position = 'absolute';
			renderer.domElement.style.top = '0px';
			renderer.domElement.style.left = '0px';
			renderer.outputEncoding = THREE.sRGBEncoding;
			renderer.toneMapping = THREE.ACESFilmicToneMapping;
			renderer.toneMappingExposure = 1;
			document.body.appendChild(renderer.domElement);

			clock = new THREE.Clock();
			deltaTime = 0;
			totalTime = 0;

			// AR Toolkit Source
			arToolkitSource = new THREEx.ArToolkitSource({ sourceType: 'webcam' });

			function onResize() {
				arToolkitSource.onResize();
				arToolkitSource.copySizeTo(renderer.domElement);
				if (arToolkitContext.arController !== null) {
					arToolkitSource.copySizeTo(arToolkitContext.arController.canvas);
				}
			}

			arToolkitSource.init(function onReady() {
				onResize();
			});

			window.addEventListener('resize', function () {
				onResize();
			});

			// AR Toolkit Context
			arToolkitContext = new THREEx.ArToolkitContext({
				cameraParametersUrl: 'data/camera_para.dat',
				detectionMode: 'mono'
			});

			arToolkitContext.init(function () {
				camera.projectionMatrix.copy(arToolkitContext.getProjectionMatrix());
			});

			// Multiple Markers + Different Objects
			setupMarkerWithModel("hiro", "watch.glb", 0.35, 0.25);		//done
			setupMarkerWithModel("kanji", "shoes.glb", 0.1, 0.25);  //done
			setupMarkerWithModel("letterA", "handbag.glb", 0.35, 0.25);  //done
			setupMarkerWithModel("letterB", "necklace.glb", 0.45, 0.25);  //done
			setupMarkerWithModel("letterC", "ring (2).glb", 0.25, 0.25);
			setupMarkerWithModel("letterF", "bracelet.glb", 0.25, 0.25);
		}

		function setupMarkerWithModel(patternName, gltfFile, scale, yPos) {
			let markerRoot = new THREE.Group();
			scene.add(markerRoot);

			let markerControls = new THREEx.ArMarkerControls(arToolkitContext, markerRoot, {
				type: 'pattern',
				patternUrl: "data/" + patternName + ".patt",
			});

			// Optional: Ground plane (transparent colored)
			let geometry = new THREE.PlaneBufferGeometry(1, 1, 4, 4);
			let material = new THREE.MeshBasicMaterial({ color: 0x00ffff, opacity: 0.3, transparent: true });
			let plane = new THREE.Mesh(geometry, material);
			plane.rotation.x = -Math.PI / 2;
			markerRoot.add(plane);

			// Load glTF model
			const loader = new THREE.GLTFLoader();
			loader.setPath('models/');
			loader.load(gltfFile, function (gltf) {
				let object = gltf.scene;
				object.scale.set(scale, scale, scale);
				object.position.y = yPos;

				// Traverse all child meshes and adjust materials
				object.traverse((child) => {
					if (child.isMesh && child.material) {
						// Ensure the material is a standard material (common in GLTF)
						const mat = child.material;

						// Optional: Ensure it's using MeshStandardMaterial
						if (mat.isMeshStandardMaterial || mat.isMeshPhysicalMaterial) {
							mat.metalness = 0.5;     // Set to your desired value (0 = non-metal, 1 = fully metallic)
							// mat.roughness = 0.5;     // Lower = shinier, higher = rougher
							// mat.side = THREE.DoubleSide;  // Optional: ensures visibility from both sides
							// Optional overrides if the material is still dark
							// if (mat.emissive) mat.emissive.set(0x222222); // slight emissive light

							mat.needsUpdate = true;
						}
					}
				});

				markerRoot.add(object);
			}, function (xhr) {
				console.log((xhr.loaded / xhr.total * 100) + '% loaded');
			}, function (error) {
				console.error('An error occurred while loading the model', error);
			});

		}

		function update() {
			if (arToolkitSource.ready !== false)
				arToolkitContext.update(arToolkitSource.domElement);
		}

		function render() {
			renderer.render(scene, camera);
		}

		function animate() {
			requestAnimationFrame(animate);
			deltaTime = clock.getDelta();
			totalTime += deltaTime;
			update();
			render();
		}

	</script>

</body>

</html>